{"version":3,"sources":["Canvas/Canvas.js","App.js","serviceWorker.js","index.js"],"names":["rectWidth","width","height","generation","nodes","createNode","row","col","isLife","ctx","object","Object","willLife","check","result","this","lifeCount","i","j","neighbourIndex","rows","show","props","indexCol","indexRow","color","fillStyle","fillRect","filledNode","nextGen","draw","document","getElementById","getContext","clearRect","forEach","node","innerText","setTimeout","window","requestAnimationFrame","Canvas","state","updateCanvas","canvasElement","offsetLeft","offsetTop","gameStart","refs","canvas","node1","Math","random","push","id","ref","React","Component","test2","App","className","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9f650f7e.chunk.js","sourcesContent":["import React from 'react';\r\nimport {setGen} from '../App';\r\n\r\n\r\nfunction filledNode(props) {\r\n    const { ctx, indexCol, indexRow, color } = props;\r\n    ctx.fillStyle = color;\r\n    // X Y 相反？\r\n    ctx.fillRect(indexCol * rectWidth, indexRow * rectWidth, rectWidth, rectWidth);\r\n}\r\n\r\n\r\nconst rows = 150;\r\nconst columns = 200;\r\n\r\nconst rectWidth = 5;\r\n\r\nconst width = columns * rectWidth;\r\nconst height = rows * rectWidth;\r\n// const width = 800;\r\n// const height = 800;\r\nvar generation = 0;\r\n\r\nconst timestep = 50;\r\n\r\nvar nodes = [];\r\n\r\nvar canvasElementOffsetLeft;\r\nvar canvasElementOffsetTop;\r\n\r\n\r\n// TODO:\r\n// 1. 手动放置初始节点\r\n// 2. \r\n// 3. \r\n// 4. \r\n\r\nfunction createNode(row, col, isLife, ctx) {\r\n    var object = new Object();\r\n    object.row = row;\r\n    object.col = col;\r\n\r\n    object.ctx = ctx;\r\n\r\n    object.isLife = isLife;\r\n    object.willLife = false;\r\n\r\n    object.check = function () {\r\n        // Any live cell with two or three neighbors survives.\r\n        // Any dead cell with three live neighbors becomes a live cell.\r\n        // All other live cells die in the next generation. Similarly, all other dead cells stay dead.\r\n\r\n        let result = false;\r\n\r\n        if (this.isLife) {\r\n            let lifeCount = 0;\r\n            for (let i = -1; i <= 1; i++) {\r\n                for (let j = -1; j <= 1; j++) {\r\n                    const neighbourIndex = (this.row + i) * columns + this.col + j;\r\n                    if (neighbourIndex >= 0 && neighbourIndex < rows * columns && this.row + i >= 0 && this.row + i < rows && this.col + j >= 0 && this.col + j < columns) {\r\n                        if (i === 0 && j === 0) { }\r\n                        else {\r\n                            if (nodes[neighbourIndex].isLife)\r\n                                lifeCount++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (lifeCount === 2 || lifeCount === 3)\r\n                result = true;\r\n        }\r\n        else {\r\n            let lifeCount = 0;\r\n            for (let i = -1; i <= 1; i++) {\r\n                for (let j = -1; j <= 1; j++) {\r\n                    const neighbourIndex = (this.row + i) * columns + this.col + j;\r\n                    if (neighbourIndex >= 0 && neighbourIndex < rows * columns && this.row + i >= 0 && this.row + i < rows && this.col + j >= 0 && this.col + j < columns) {\r\n                        if (i === 0 && j === 0) { }\r\n                        else {\r\n                            if (nodes[neighbourIndex].isLife)\r\n                                lifeCount++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (lifeCount === 3)\r\n                result = true;\r\n        }\r\n\r\n\r\n        // set willLife if this node will be a life in next generation\r\n        this.willLife = result;\r\n    }\r\n\r\n    object.show = function () {\r\n        filledNode({ ctx: this.ctx, indexCol: this.col, indexRow: this.row, color: this.isLife ? \"#FFFFFB\" : \"#111111\" });\r\n    }\r\n\r\n    object.nextGen = function () {\r\n        this.isLife = this.willLife;\r\n        this.willLife = false;\r\n    }\r\n\r\n    return object;\r\n}\r\n\r\nfunction draw() {\r\n    const canvas = document.getElementById(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    // drawCoordinateLine();\r\n\r\n    // show finished particles\r\n\r\n\r\n    nodes.forEach(node => {\r\n        // chech the next state\r\n        node.check();\r\n        // show current on screen\r\n        node.show();\r\n    });\r\n\r\n    nodes.forEach(node => {\r\n        // update state to the next state\r\n        node.nextGen();\r\n    });\r\n\r\n    generation++;\r\n    // console.log(generation);\r\n\r\n    const textAre = document.getElementById(\"gentext\");\r\n    textAre.innerText = 'generations: ' + generation;\r\n    // setGen(generation);\r\n\r\n    setTimeout(function () { window.requestAnimationFrame(draw); }, timestep);\r\n    // var raf = window.requestAnimationFrame(draw);\r\n}\r\n\r\n\r\nclass Canvas extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updateCanvas();\r\n\r\n        var canvasElement = document.getElementById(\"canvas\");\r\n        canvasElementOffsetLeft = canvasElement.offsetLeft;\r\n        canvasElementOffsetTop = canvasElement.offsetTop;\r\n\r\n        this.gameStart();\r\n    }\r\n    componentDidUpdate() {\r\n        this.updateCanvas();\r\n    }\r\n    updateCanvas() {\r\n        const ctx = this.refs.canvas.getContext('2d');\r\n\r\n        ctx.clearRect(0, 0, width, height);\r\n\r\n        ctx.fillStyle = \"#2C2C2C\";\r\n        ctx.fillRect(0, 0, width, height);\r\n\r\n    }\r\n\r\n    gameStart() {\r\n        const ctx = this.refs.canvas.getContext('2d');\r\n        for (let i = 0; i < rows; i++) {\r\n            for (let j = 0; j < columns; j++) {\r\n                // if ((i * j) % 3 === 0) {\r\n                //     var node1 = createNode(i, j, true, ctx);\r\n                //     nodes.push(node1);\r\n                // }\r\n                // else {\r\n                //     var node2 = createNode(i, j, false, ctx);\r\n                //     nodes.push(node2);\r\n                // }\r\n                const temp = Math.random();\r\n\r\n                var node1 = createNode(i, j, temp > 0.7 ? true : false, ctx);\r\n                nodes.push(node1);\r\n            }\r\n        }\r\n\r\n        // document.getElementById(\"gentext\").value = 'generations: 111';\r\n\r\n        draw();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas id='canvas' ref=\"canvas\" width={width} height={height} />\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;\r\nexport const getGeneration = () => { \r\n    return generation; \r\n} ","import React from 'react';\nimport Canvas from './Canvas/Canvas';\nimport './App.css';\nimport { getGeneration } from './Canvas/Canvas';\n\nlet test1 = \"Conway's Game of Life\";\nlet test2 = \"generations: \";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div className=\"Heading2\">{test1}</div>\n        <div className=\"Heading3\" id=\"gentext\">{test2}</div>\n        <Canvas id=\"canvas\" />\n\n      </header>\n    </div>\n  );\n}\n\nexport default App;\nexport const setGen = (text) => {\n  test2 = text;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}